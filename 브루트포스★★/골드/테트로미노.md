> [ https://www.acmicpc.net/problem/14500 ]( https://www.acmicpc.net/problem/14500 )   

# 해결 전략

</br>

## 1.  DFS + 브루트포스
- 테트로미노중 ㅗ 모양을 제외한 모양은 DFS로 처리했다.
- ㅗ 모양은 한 점을 중심으로 ㅗ, ㅜ, ㅏ, ㅓ 중 최대값을 구했다.
- 위 두 과정은 시간복잡도에서 + 연산이기 때문에 good

## 2. DFS에서 visited 주의점
- 아래 코드를 보자.
- visited=0 처리는 dfs의 return마다 해줘야 한다.
- 그런데 코드 중간에 조건문으로 return하는 코드 있을 시 visited = 0 을 까먹기 쉽기때문에 주의하자.
```python
def DFS(y, x, cnt, r):

    ~~

    if ~~:
        visited[y][x]=0
        return
    
    ~~

    visited[y][x] = 0
    return
```
- 또, visited=1 과 visted=0 을 dfs 전후에 해줘도 상관 없다.
    - 이럴 경우, main함수에서 dfs를 호출하는 전후에도 해줘야 한다.

## 3. pypy3
- 반복연산이 많기때문에 pypy3로 제출해서 통과했다.
- setrecursionlimit 했더니 메모리초과났다.

</br>

# 코드

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())

baseArr = []
visited = [ [0 for i in range(501)] for i in range(501) ]
ans=0

for i in range(n):
    st = list(map(int, input().split()))
    baseArr.append(st)

where = [ [1,0], [-1,0], [0,1], [0,-1] ]

def DFS(y, x, cnt, r):
    global ans
    visited[y][x] = 1

    if cnt==4:
        ans = max(ans, r)
        
        # 까먹지 않게 주의
        visited[y][x]=0
        return
    
    for i in range(4):
        nY = y + where[i][0]
        nX = x + where[i][1]

        if 0 <= nY < n and 0 <= nX < m and visited[nY][nX] == 0:
            DFS(nY, nX, cnt+1, r+baseArr[nY][nX])
    
    visited[y][x] = 0
    return

def checkMountain(y, x):
    global ans
    
    # 꼭지점 -> 무시
    if (y==0 and x==0) or (y==0 and x==m-1) or (y==n-1 and x==0) or (y==n-1 and x==m-1):
        return

    # 모서리 -> 특수처리
    if y==0:
        tmpAns = baseArr[0][x] + baseArr[0][x-1] + baseArr[0][x+1]+ baseArr[1][x]
        ans = max(ans, tmpAns)
        return

    if y==n-1:
        tmpAns = baseArr[y][x] + baseArr[y][x-1] + baseArr[y][x+1]+ baseArr[y-1][x]
        ans = max(ans, tmpAns)
        return
    
    if x==0:
        tmpAns = baseArr[y][0] + baseArr[y-1][0] + baseArr[y+1][0]+ baseArr[y][x+1]
        ans = max(ans, tmpAns)
        return

    if x==m-1:
        tmpAns = baseArr[y][x] + baseArr[y+1][x] + baseArr[y-1][x]+ baseArr[y][x-1]
        ans = max(ans, tmpAns)
        return
    
    # 내부점 -> 십자가모양에서 상하좌우점 중 최소값 빼주기
    tmpSum = baseArr[y][x] + baseArr[y+1][x] + baseArr[y-1][x]+ baseArr[y][x-1] + baseArr[y][x+1]

    tmpMin = min(baseArr[y+1][x], baseArr[y-1][x], baseArr[y][x-1], baseArr[y][x+1])
    tmpAns = tmpSum - tmpMin
    ans = max(ans, tmpAns)
    return

for i in range(n):
    for j in range(m):
        DFS(i,j,1,baseArr[i][j])

for i in range(n):
    for j in range(m):
        checkMountain(i, j)

print(ans)
```